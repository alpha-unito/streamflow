# Generated from ECMAScript.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,103,625,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,1,0,3,0,112,8,0,1,0,1,0,1,1,4,1,117,8,1,11,
        1,12,1,118,1,2,1,2,1,2,3,2,124,8,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,142,8,3,1,4,1,4,3,4,146,8,
        4,1,4,1,4,1,5,4,5,151,8,5,11,5,12,5,152,1,6,1,6,1,6,1,6,1,7,1,7,
        1,7,5,7,162,8,7,10,7,12,7,165,9,7,1,8,1,8,3,8,169,8,8,1,9,1,9,1,
        9,1,10,1,10,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,
        12,186,8,12,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,
        13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,205,8,13,1,13,1,13,3,13,209,
        8,13,1,13,1,13,3,13,213,8,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
        1,13,3,13,223,8,13,1,13,1,13,3,13,227,8,13,1,13,1,13,1,13,1,13,1,
        13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,
        13,1,13,1,13,3,13,249,8,13,1,14,1,14,1,14,3,14,254,8,14,1,14,1,14,
        1,15,1,15,1,15,3,15,261,8,15,1,15,1,15,1,16,1,16,1,16,3,16,268,8,
        16,1,16,1,16,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,18,1,
        18,1,18,1,19,1,19,3,19,286,8,19,1,19,1,19,3,19,290,8,19,3,19,292,
        8,19,1,19,1,19,1,20,4,20,297,8,20,11,20,12,20,298,1,21,1,21,1,21,
        1,21,3,21,305,8,21,1,22,1,22,1,22,3,22,310,8,22,1,23,1,23,1,23,1,
        23,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,
        25,1,25,1,25,1,25,1,25,1,25,3,25,334,8,25,1,26,1,26,1,26,1,26,1,
        26,1,26,1,27,1,27,1,27,1,28,1,28,1,28,1,29,1,29,1,29,1,29,3,29,352,
        8,29,1,29,1,29,1,29,1,29,1,29,1,30,1,30,1,30,5,30,362,8,30,10,30,
        12,30,365,9,30,1,31,3,31,368,8,31,1,32,1,32,3,32,372,8,32,1,32,3,
        32,375,8,32,1,32,3,32,378,8,32,1,32,1,32,1,33,3,33,383,8,33,1,33,
        1,33,1,33,3,33,388,8,33,1,33,5,33,391,8,33,10,33,12,33,394,9,33,
        1,34,4,34,397,8,34,11,34,12,34,398,1,35,1,35,1,35,1,35,1,35,3,35,
        406,8,35,1,35,1,35,3,35,410,8,35,1,36,1,36,1,36,5,36,415,8,36,10,
        36,12,36,418,9,36,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,
        37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,439,8,37,1,
        38,1,38,1,38,3,38,444,8,38,1,39,1,39,1,40,1,40,3,40,450,8,40,1,40,
        1,40,1,41,1,41,1,41,5,41,457,8,41,10,41,12,41,460,9,41,1,42,1,42,
        1,42,5,42,465,8,42,10,42,12,42,468,9,42,1,43,1,43,1,43,3,43,473,
        8,43,1,43,1,43,3,43,477,8,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,3,43,487,8,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,3,43,516,8,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,5,43,583,8,43,10,43,12,43,
        586,9,43,1,44,1,44,1,45,1,45,3,45,592,8,45,1,46,1,46,1,47,1,47,3,
        47,598,8,47,1,48,1,48,1,48,3,48,603,8,48,1,49,1,49,1,50,1,50,1,51,
        1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,53,1,53,1,53,1,53,3,53,621,
        8,53,1,54,1,54,1,54,0,1,86,55,0,2,4,6,8,10,12,14,16,18,20,22,24,
        26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
        70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
        0,11,1,0,21,23,1,0,17,18,1,0,24,26,1,0,27,30,1,0,31,34,1,0,40,50,
        3,0,1,1,51,52,99,99,1,0,53,55,1,0,51,52,1,0,56,81,1,0,82,97,678,
        0,111,1,0,0,0,2,116,1,0,0,0,4,123,1,0,0,0,6,141,1,0,0,0,8,143,1,
        0,0,0,10,150,1,0,0,0,12,154,1,0,0,0,14,158,1,0,0,0,16,166,1,0,0,
        0,18,170,1,0,0,0,20,173,1,0,0,0,22,175,1,0,0,0,24,178,1,0,0,0,26,
        248,1,0,0,0,28,250,1,0,0,0,30,257,1,0,0,0,32,264,1,0,0,0,34,271,
        1,0,0,0,36,277,1,0,0,0,38,283,1,0,0,0,40,296,1,0,0,0,42,300,1,0,
        0,0,44,306,1,0,0,0,46,311,1,0,0,0,48,315,1,0,0,0,50,333,1,0,0,0,
        52,335,1,0,0,0,54,341,1,0,0,0,56,344,1,0,0,0,58,347,1,0,0,0,60,358,
        1,0,0,0,62,367,1,0,0,0,64,369,1,0,0,0,66,382,1,0,0,0,68,396,1,0,
        0,0,70,409,1,0,0,0,72,411,1,0,0,0,74,438,1,0,0,0,76,443,1,0,0,0,
        78,445,1,0,0,0,80,447,1,0,0,0,82,453,1,0,0,0,84,461,1,0,0,0,86,515,
        1,0,0,0,88,587,1,0,0,0,90,591,1,0,0,0,92,593,1,0,0,0,94,597,1,0,
        0,0,96,602,1,0,0,0,98,604,1,0,0,0,100,606,1,0,0,0,102,608,1,0,0,
        0,104,612,1,0,0,0,106,620,1,0,0,0,108,622,1,0,0,0,110,112,3,2,1,
        0,111,110,1,0,0,0,111,112,1,0,0,0,112,113,1,0,0,0,113,114,5,0,0,
        1,114,1,1,0,0,0,115,117,3,4,2,0,116,115,1,0,0,0,117,118,1,0,0,0,
        118,116,1,0,0,0,118,119,1,0,0,0,119,3,1,0,0,0,120,121,4,2,0,0,121,
        124,3,6,3,0,122,124,3,58,29,0,123,120,1,0,0,0,123,122,1,0,0,0,124,
        5,1,0,0,0,125,142,3,8,4,0,126,142,3,12,6,0,127,142,3,20,10,0,128,
        129,4,3,1,0,129,142,3,22,11,0,130,142,3,24,12,0,131,142,3,26,13,
        0,132,142,3,28,14,0,133,142,3,30,15,0,134,142,3,32,16,0,135,142,
        3,34,17,0,136,142,3,46,23,0,137,142,3,36,18,0,138,142,3,48,24,0,
        139,142,3,50,25,0,140,142,3,56,28,0,141,125,1,0,0,0,141,126,1,0,
        0,0,141,127,1,0,0,0,141,128,1,0,0,0,141,130,1,0,0,0,141,131,1,0,
        0,0,141,132,1,0,0,0,141,133,1,0,0,0,141,134,1,0,0,0,141,135,1,0,
        0,0,141,136,1,0,0,0,141,137,1,0,0,0,141,138,1,0,0,0,141,139,1,0,
        0,0,141,140,1,0,0,0,142,7,1,0,0,0,143,145,5,7,0,0,144,146,3,10,5,
        0,145,144,1,0,0,0,145,146,1,0,0,0,146,147,1,0,0,0,147,148,5,8,0,
        0,148,9,1,0,0,0,149,151,3,6,3,0,150,149,1,0,0,0,151,152,1,0,0,0,
        152,150,1,0,0,0,152,153,1,0,0,0,153,11,1,0,0,0,154,155,5,63,0,0,
        155,156,3,14,7,0,156,157,3,106,53,0,157,13,1,0,0,0,158,163,3,16,
        8,0,159,160,5,10,0,0,160,162,3,16,8,0,161,159,1,0,0,0,162,165,1,
        0,0,0,163,161,1,0,0,0,163,164,1,0,0,0,164,15,1,0,0,0,165,163,1,0,
        0,0,166,168,5,98,0,0,167,169,3,18,9,0,168,167,1,0,0,0,168,169,1,
        0,0,0,169,17,1,0,0,0,170,171,5,11,0,0,171,172,3,86,43,0,172,19,1,
        0,0,0,173,174,5,9,0,0,174,21,1,0,0,0,175,176,3,84,42,0,176,177,3,
        106,53,0,177,23,1,0,0,0,178,179,5,77,0,0,179,180,5,5,0,0,180,181,
        3,84,42,0,181,182,5,6,0,0,182,185,3,6,3,0,183,184,5,61,0,0,184,186,
        3,6,3,0,185,183,1,0,0,0,185,186,1,0,0,0,186,25,1,0,0,0,187,188,5,
        57,0,0,188,189,3,6,3,0,189,190,5,71,0,0,190,191,5,5,0,0,191,192,
        3,84,42,0,192,193,5,6,0,0,193,194,3,106,53,0,194,249,1,0,0,0,195,
        196,5,71,0,0,196,197,5,5,0,0,197,198,3,84,42,0,198,199,5,6,0,0,199,
        200,3,6,3,0,200,249,1,0,0,0,201,202,5,69,0,0,202,204,5,5,0,0,203,
        205,3,84,42,0,204,203,1,0,0,0,204,205,1,0,0,0,205,206,1,0,0,0,206,
        208,5,9,0,0,207,209,3,84,42,0,208,207,1,0,0,0,208,209,1,0,0,0,209,
        210,1,0,0,0,210,212,5,9,0,0,211,213,3,84,42,0,212,211,1,0,0,0,212,
        213,1,0,0,0,213,214,1,0,0,0,214,215,5,6,0,0,215,249,3,6,3,0,216,
        217,5,69,0,0,217,218,5,5,0,0,218,219,5,63,0,0,219,220,3,14,7,0,220,
        222,5,9,0,0,221,223,3,84,42,0,222,221,1,0,0,0,222,223,1,0,0,0,223,
        224,1,0,0,0,224,226,5,9,0,0,225,227,3,84,42,0,226,225,1,0,0,0,226,
        227,1,0,0,0,227,228,1,0,0,0,228,229,5,6,0,0,229,230,3,6,3,0,230,
        249,1,0,0,0,231,232,5,69,0,0,232,233,5,5,0,0,233,234,3,86,43,0,234,
        235,5,80,0,0,235,236,3,84,42,0,236,237,5,6,0,0,237,238,3,6,3,0,238,
        249,1,0,0,0,239,240,5,69,0,0,240,241,5,5,0,0,241,242,5,63,0,0,242,
        243,3,16,8,0,243,244,5,80,0,0,244,245,3,84,42,0,245,246,5,6,0,0,
        246,247,3,6,3,0,247,249,1,0,0,0,248,187,1,0,0,0,248,195,1,0,0,0,
        248,201,1,0,0,0,248,216,1,0,0,0,248,231,1,0,0,0,248,239,1,0,0,0,
        249,27,1,0,0,0,250,253,5,68,0,0,251,252,4,14,2,0,252,254,5,98,0,
        0,253,251,1,0,0,0,253,254,1,0,0,0,254,255,1,0,0,0,255,256,3,106,
        53,0,256,29,1,0,0,0,257,260,5,56,0,0,258,259,4,15,3,0,259,261,5,
        98,0,0,260,258,1,0,0,0,260,261,1,0,0,0,261,262,1,0,0,0,262,263,3,
        106,53,0,263,31,1,0,0,0,264,267,5,66,0,0,265,266,4,16,4,0,266,268,
        3,84,42,0,267,265,1,0,0,0,267,268,1,0,0,0,268,269,1,0,0,0,269,270,
        3,106,53,0,270,33,1,0,0,0,271,272,5,75,0,0,272,273,5,5,0,0,273,274,
        3,84,42,0,274,275,5,6,0,0,275,276,3,6,3,0,276,35,1,0,0,0,277,278,
        5,70,0,0,278,279,5,5,0,0,279,280,3,84,42,0,280,281,5,6,0,0,281,282,
        3,38,19,0,282,37,1,0,0,0,283,285,5,7,0,0,284,286,3,40,20,0,285,284,
        1,0,0,0,285,286,1,0,0,0,286,291,1,0,0,0,287,289,3,44,22,0,288,290,
        3,40,20,0,289,288,1,0,0,0,289,290,1,0,0,0,290,292,1,0,0,0,291,287,
        1,0,0,0,291,292,1,0,0,0,292,293,1,0,0,0,293,294,5,8,0,0,294,39,1,
        0,0,0,295,297,3,42,21,0,296,295,1,0,0,0,297,298,1,0,0,0,298,296,
        1,0,0,0,298,299,1,0,0,0,299,41,1,0,0,0,300,301,5,60,0,0,301,302,
        3,84,42,0,302,304,5,13,0,0,303,305,3,10,5,0,304,303,1,0,0,0,304,
        305,1,0,0,0,305,43,1,0,0,0,306,307,5,76,0,0,307,309,5,13,0,0,308,
        310,3,10,5,0,309,308,1,0,0,0,309,310,1,0,0,0,310,45,1,0,0,0,311,
        312,5,98,0,0,312,313,5,13,0,0,313,314,3,6,3,0,314,47,1,0,0,0,315,
        316,5,78,0,0,316,317,4,24,5,0,317,318,3,84,42,0,318,319,3,106,53,
        0,319,49,1,0,0,0,320,321,5,81,0,0,321,322,3,8,4,0,322,323,3,52,26,
        0,323,334,1,0,0,0,324,325,5,81,0,0,325,326,3,8,4,0,326,327,3,54,
        27,0,327,334,1,0,0,0,328,329,5,81,0,0,329,330,3,8,4,0,330,331,3,
        52,26,0,331,332,3,54,27,0,332,334,1,0,0,0,333,320,1,0,0,0,333,324,
        1,0,0,0,333,328,1,0,0,0,334,51,1,0,0,0,335,336,5,64,0,0,336,337,
        5,5,0,0,337,338,5,98,0,0,338,339,5,6,0,0,339,340,3,8,4,0,340,53,
        1,0,0,0,341,342,5,65,0,0,342,343,3,8,4,0,343,55,1,0,0,0,344,345,
        5,72,0,0,345,346,3,106,53,0,346,57,1,0,0,0,347,348,5,73,0,0,348,
        349,5,98,0,0,349,351,5,5,0,0,350,352,3,60,30,0,351,350,1,0,0,0,351,
        352,1,0,0,0,352,353,1,0,0,0,353,354,5,6,0,0,354,355,5,7,0,0,355,
        356,3,62,31,0,356,357,5,8,0,0,357,59,1,0,0,0,358,363,5,98,0,0,359,
        360,5,10,0,0,360,362,5,98,0,0,361,359,1,0,0,0,362,365,1,0,0,0,363,
        361,1,0,0,0,363,364,1,0,0,0,364,61,1,0,0,0,365,363,1,0,0,0,366,368,
        3,2,1,0,367,366,1,0,0,0,367,368,1,0,0,0,368,63,1,0,0,0,369,371,5,
        3,0,0,370,372,3,66,33,0,371,370,1,0,0,0,371,372,1,0,0,0,372,374,
        1,0,0,0,373,375,5,10,0,0,374,373,1,0,0,0,374,375,1,0,0,0,375,377,
        1,0,0,0,376,378,3,68,34,0,377,376,1,0,0,0,377,378,1,0,0,0,378,379,
        1,0,0,0,379,380,5,4,0,0,380,65,1,0,0,0,381,383,3,68,34,0,382,381,
        1,0,0,0,382,383,1,0,0,0,383,384,1,0,0,0,384,392,3,86,43,0,385,387,
        5,10,0,0,386,388,3,68,34,0,387,386,1,0,0,0,387,388,1,0,0,0,388,389,
        1,0,0,0,389,391,3,86,43,0,390,385,1,0,0,0,391,394,1,0,0,0,392,390,
        1,0,0,0,392,393,1,0,0,0,393,67,1,0,0,0,394,392,1,0,0,0,395,397,5,
        10,0,0,396,395,1,0,0,0,397,398,1,0,0,0,398,396,1,0,0,0,398,399,1,
        0,0,0,399,69,1,0,0,0,400,401,5,7,0,0,401,410,5,8,0,0,402,403,5,7,
        0,0,403,405,3,72,36,0,404,406,5,10,0,0,405,404,1,0,0,0,405,406,1,
        0,0,0,406,407,1,0,0,0,407,408,5,8,0,0,408,410,1,0,0,0,409,400,1,
        0,0,0,409,402,1,0,0,0,410,71,1,0,0,0,411,416,3,74,37,0,412,413,5,
        10,0,0,413,415,3,74,37,0,414,412,1,0,0,0,415,418,1,0,0,0,416,414,
        1,0,0,0,416,417,1,0,0,0,417,73,1,0,0,0,418,416,1,0,0,0,419,420,3,
        76,38,0,420,421,5,13,0,0,421,422,3,86,43,0,422,439,1,0,0,0,423,424,
        3,102,51,0,424,425,5,5,0,0,425,426,5,6,0,0,426,427,5,7,0,0,427,428,
        3,62,31,0,428,429,5,8,0,0,429,439,1,0,0,0,430,431,3,104,52,0,431,
        432,5,5,0,0,432,433,3,78,39,0,433,434,5,6,0,0,434,435,5,7,0,0,435,
        436,3,62,31,0,436,437,5,8,0,0,437,439,1,0,0,0,438,419,1,0,0,0,438,
        423,1,0,0,0,438,430,1,0,0,0,439,75,1,0,0,0,440,444,3,94,47,0,441,
        444,5,99,0,0,442,444,3,92,46,0,443,440,1,0,0,0,443,441,1,0,0,0,443,
        442,1,0,0,0,444,77,1,0,0,0,445,446,5,98,0,0,446,79,1,0,0,0,447,449,
        5,5,0,0,448,450,3,82,41,0,449,448,1,0,0,0,449,450,1,0,0,0,450,451,
        1,0,0,0,451,452,5,6,0,0,452,81,1,0,0,0,453,458,3,86,43,0,454,455,
        5,10,0,0,455,457,3,86,43,0,456,454,1,0,0,0,457,460,1,0,0,0,458,456,
        1,0,0,0,458,459,1,0,0,0,459,83,1,0,0,0,460,458,1,0,0,0,461,466,3,
        86,43,0,462,463,5,10,0,0,463,465,3,86,43,0,464,462,1,0,0,0,465,468,
        1,0,0,0,466,464,1,0,0,0,466,467,1,0,0,0,467,85,1,0,0,0,468,466,1,
        0,0,0,469,470,6,43,-1,0,470,472,5,73,0,0,471,473,5,98,0,0,472,471,
        1,0,0,0,472,473,1,0,0,0,473,474,1,0,0,0,474,476,5,5,0,0,475,477,
        3,60,30,0,476,475,1,0,0,0,476,477,1,0,0,0,477,478,1,0,0,0,478,479,
        5,6,0,0,479,480,5,7,0,0,480,481,3,62,31,0,481,482,5,8,0,0,482,516,
        1,0,0,0,483,484,5,62,0,0,484,486,3,86,43,0,485,487,3,80,40,0,486,
        485,1,0,0,0,486,487,1,0,0,0,487,516,1,0,0,0,488,489,5,79,0,0,489,
        516,3,86,43,30,490,491,5,67,0,0,491,516,3,86,43,29,492,493,5,59,
        0,0,493,516,3,86,43,28,494,495,5,15,0,0,495,516,3,86,43,27,496,497,
        5,16,0,0,497,516,3,86,43,26,498,499,5,17,0,0,499,516,3,86,43,25,
        500,501,5,18,0,0,501,516,3,86,43,24,502,503,5,19,0,0,503,516,3,86,
        43,23,504,505,5,20,0,0,505,516,3,86,43,22,506,516,5,74,0,0,507,516,
        5,98,0,0,508,516,3,90,45,0,509,516,3,64,32,0,510,516,3,70,35,0,511,
        512,5,5,0,0,512,513,3,84,42,0,513,514,5,6,0,0,514,516,1,0,0,0,515,
        469,1,0,0,0,515,483,1,0,0,0,515,488,1,0,0,0,515,490,1,0,0,0,515,
        492,1,0,0,0,515,494,1,0,0,0,515,496,1,0,0,0,515,498,1,0,0,0,515,
        500,1,0,0,0,515,502,1,0,0,0,515,504,1,0,0,0,515,506,1,0,0,0,515,
        507,1,0,0,0,515,508,1,0,0,0,515,509,1,0,0,0,515,510,1,0,0,0,515,
        511,1,0,0,0,516,584,1,0,0,0,517,518,10,21,0,0,518,519,7,0,0,0,519,
        583,3,86,43,22,520,521,10,20,0,0,521,522,7,1,0,0,522,583,3,86,43,
        21,523,524,10,19,0,0,524,525,7,2,0,0,525,583,3,86,43,20,526,527,
        10,18,0,0,527,528,7,3,0,0,528,583,3,86,43,19,529,530,10,17,0,0,530,
        531,5,58,0,0,531,583,3,86,43,18,532,533,10,16,0,0,533,534,5,80,0,
        0,534,583,3,86,43,17,535,536,10,15,0,0,536,537,7,4,0,0,537,583,3,
        86,43,16,538,539,10,14,0,0,539,540,5,35,0,0,540,583,3,86,43,15,541,
        542,10,13,0,0,542,543,5,36,0,0,543,583,3,86,43,14,544,545,10,12,
        0,0,545,546,5,37,0,0,546,583,3,86,43,13,547,548,10,11,0,0,548,549,
        5,38,0,0,549,583,3,86,43,12,550,551,10,10,0,0,551,552,5,39,0,0,552,
        583,3,86,43,11,553,554,10,9,0,0,554,555,5,12,0,0,555,556,3,86,43,
        0,556,557,5,13,0,0,557,558,3,86,43,10,558,583,1,0,0,0,559,560,10,
        8,0,0,560,561,5,11,0,0,561,583,3,86,43,9,562,563,10,7,0,0,563,564,
        3,88,44,0,564,565,3,86,43,8,565,583,1,0,0,0,566,567,10,36,0,0,567,
        568,5,3,0,0,568,569,3,84,42,0,569,570,5,4,0,0,570,583,1,0,0,0,571,
        572,10,35,0,0,572,573,5,14,0,0,573,583,3,94,47,0,574,575,10,34,0,
        0,575,583,3,80,40,0,576,577,10,32,0,0,577,578,4,43,25,0,578,583,
        5,15,0,0,579,580,10,31,0,0,580,581,4,43,27,0,581,583,5,16,0,0,582,
        517,1,0,0,0,582,520,1,0,0,0,582,523,1,0,0,0,582,526,1,0,0,0,582,
        529,1,0,0,0,582,532,1,0,0,0,582,535,1,0,0,0,582,538,1,0,0,0,582,
        541,1,0,0,0,582,544,1,0,0,0,582,547,1,0,0,0,582,550,1,0,0,0,582,
        553,1,0,0,0,582,559,1,0,0,0,582,562,1,0,0,0,582,566,1,0,0,0,582,
        571,1,0,0,0,582,574,1,0,0,0,582,576,1,0,0,0,582,579,1,0,0,0,583,
        586,1,0,0,0,584,582,1,0,0,0,584,585,1,0,0,0,585,87,1,0,0,0,586,584,
        1,0,0,0,587,588,7,5,0,0,588,89,1,0,0,0,589,592,7,6,0,0,590,592,3,
        92,46,0,591,589,1,0,0,0,591,590,1,0,0,0,592,91,1,0,0,0,593,594,7,
        7,0,0,594,93,1,0,0,0,595,598,5,98,0,0,596,598,3,96,48,0,597,595,
        1,0,0,0,597,596,1,0,0,0,598,95,1,0,0,0,599,603,3,98,49,0,600,603,
        3,100,50,0,601,603,7,8,0,0,602,599,1,0,0,0,602,600,1,0,0,0,602,601,
        1,0,0,0,603,97,1,0,0,0,604,605,7,9,0,0,605,99,1,0,0,0,606,607,7,
        10,0,0,607,101,1,0,0,0,608,609,4,51,28,0,609,610,5,98,0,0,610,611,
        3,76,38,0,611,103,1,0,0,0,612,613,4,52,29,0,613,614,5,98,0,0,614,
        615,3,76,38,0,615,105,1,0,0,0,616,621,5,9,0,0,617,621,5,0,0,1,618,
        621,4,53,30,0,619,621,4,53,31,0,620,616,1,0,0,0,620,617,1,0,0,0,
        620,618,1,0,0,0,620,619,1,0,0,0,621,107,1,0,0,0,622,623,5,0,0,1,
        623,109,1,0,0,0,53,111,118,123,141,145,152,163,168,185,204,208,212,
        222,226,248,253,260,267,285,289,291,298,304,309,333,351,363,367,
        371,374,377,382,387,392,398,405,409,416,438,443,449,458,466,472,
        476,486,515,582,584,591,597,602,620
    ]

class ECMAScriptParser ( Parser ):

    grammarFileName = "ECMAScript.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "'['", "']'", 
                     "'('", "')'", "'{'", "'}'", "';'", "','", "'='", "'?'", 
                     "':'", "'.'", "'++'", "'--'", "'+'", "'-'", "'~'", 
                     "'!'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'>>>'", 
                     "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", "'==='", 
                     "'!=='", "'&'", "'^'", "'|'", "'&&'", "'||'", "'*='", 
                     "'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='", 
                     "'&='", "'^='", "'|='", "'null'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'break'", "'do'", "'instanceof'", 
                     "'typeof'", "'case'", "'else'", "'new'", "'var'", "'catch'", 
                     "'finally'", "'return'", "'void'", "'continue'", "'for'", 
                     "'switch'", "'while'", "'debugger'", "'function'", 
                     "'this'", "'with'", "'default'", "'if'", "'throw'", 
                     "'delete'", "'in'", "'try'", "'class'", "'enum'", "'extends'", 
                     "'super'", "'const'", "'export'", "'import'" ]

    symbolicNames = [ "<INVALID>", "RegularExpressionLiteral", "LineTerminator", 
                      "OpenBracket", "CloseBracket", "OpenParen", "CloseParen", 
                      "OpenBrace", "CloseBrace", "SemiColon", "Comma", "Assign", 
                      "QuestionMark", "Colon", "Dot", "PlusPlus", "MinusMinus", 
                      "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", 
                      "Modulus", "RightShiftArithmetic", "LeftShiftArithmetic", 
                      "RightShiftLogical", "LessThan", "MoreThan", "LessThanEquals", 
                      "GreaterThanEquals", "Equals", "NotEquals", "IdentityEquals", 
                      "IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", 
                      "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign", 
                      "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", 
                      "RightShiftArithmeticAssign", "RightShiftLogicalAssign", 
                      "BitAndAssign", "BitXorAssign", "BitOrAssign", "NullLiteral", 
                      "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", 
                      "OctalIntegerLiteral", "Break", "Do", "Instanceof", 
                      "Typeof", "Case", "Else", "New", "Var", "Catch", "Finally", 
                      "Return", "Void", "Continue", "For", "Switch", "While", 
                      "Debugger", "Function", "This", "With", "Default", 
                      "If", "Throw", "Delete", "In", "Try", "Class", "Enum", 
                      "Extends", "Super", "Const", "Export", "Import", "Implements", 
                      "Let", "Private", "Public", "Interface", "Package", 
                      "Protected", "Static", "Yield", "Identifier", "StringLiteral", 
                      "WhiteSpaces", "MultiLineComment", "SingleLineComment", 
                      "UnexpectedCharacter" ]

    RULE_program = 0
    RULE_sourceElements = 1
    RULE_sourceElement = 2
    RULE_statement = 3
    RULE_block = 4
    RULE_statementList = 5
    RULE_variableStatement = 6
    RULE_variableDeclarationList = 7
    RULE_variableDeclaration = 8
    RULE_initialiser = 9
    RULE_emptyStatement_ = 10
    RULE_expressionStatement = 11
    RULE_ifStatement = 12
    RULE_iterationStatement = 13
    RULE_continueStatement = 14
    RULE_breakStatement = 15
    RULE_returnStatement = 16
    RULE_withStatement = 17
    RULE_switchStatement = 18
    RULE_caseBlock = 19
    RULE_caseClauses = 20
    RULE_caseClause = 21
    RULE_defaultClause = 22
    RULE_labelledStatement = 23
    RULE_throwStatement = 24
    RULE_tryStatement = 25
    RULE_catchProduction = 26
    RULE_finallyProduction = 27
    RULE_debuggerStatement = 28
    RULE_functionDeclaration = 29
    RULE_formalParameterList = 30
    RULE_functionBody = 31
    RULE_arrayLiteral = 32
    RULE_elementList = 33
    RULE_elision = 34
    RULE_objectLiteral = 35
    RULE_propertyNameAndValueList = 36
    RULE_propertyAssignment = 37
    RULE_propertyName = 38
    RULE_propertySetParameterList = 39
    RULE_arguments = 40
    RULE_argumentList = 41
    RULE_expressionSequence = 42
    RULE_singleExpression = 43
    RULE_assignmentOperator = 44
    RULE_literal = 45
    RULE_numericLiteral = 46
    RULE_identifierName = 47
    RULE_reservedWord = 48
    RULE_keyword = 49
    RULE_futureReservedWord = 50
    RULE_getter = 51
    RULE_setter = 52
    RULE_eos = 53
    RULE_eof = 54

    ruleNames =  [ "program", "sourceElements", "sourceElement", "statement", 
                   "block", "statementList", "variableStatement", "variableDeclarationList", 
                   "variableDeclaration", "initialiser", "emptyStatement_", 
                   "expressionStatement", "ifStatement", "iterationStatement", 
                   "continueStatement", "breakStatement", "returnStatement", 
                   "withStatement", "switchStatement", "caseBlock", "caseClauses", 
                   "caseClause", "defaultClause", "labelledStatement", "throwStatement", 
                   "tryStatement", "catchProduction", "finallyProduction", 
                   "debuggerStatement", "functionDeclaration", "formalParameterList", 
                   "functionBody", "arrayLiteral", "elementList", "elision", 
                   "objectLiteral", "propertyNameAndValueList", "propertyAssignment", 
                   "propertyName", "propertySetParameterList", "arguments", 
                   "argumentList", "expressionSequence", "singleExpression", 
                   "assignmentOperator", "literal", "numericLiteral", "identifierName", 
                   "reservedWord", "keyword", "futureReservedWord", "getter", 
                   "setter", "eos", "eof" ]

    EOF = Token.EOF
    RegularExpressionLiteral=1
    LineTerminator=2
    OpenBracket=3
    CloseBracket=4
    OpenParen=5
    CloseParen=6
    OpenBrace=7
    CloseBrace=8
    SemiColon=9
    Comma=10
    Assign=11
    QuestionMark=12
    Colon=13
    Dot=14
    PlusPlus=15
    MinusMinus=16
    Plus=17
    Minus=18
    BitNot=19
    Not=20
    Multiply=21
    Divide=22
    Modulus=23
    RightShiftArithmetic=24
    LeftShiftArithmetic=25
    RightShiftLogical=26
    LessThan=27
    MoreThan=28
    LessThanEquals=29
    GreaterThanEquals=30
    Equals=31
    NotEquals=32
    IdentityEquals=33
    IdentityNotEquals=34
    BitAnd=35
    BitXOr=36
    BitOr=37
    And=38
    Or=39
    MultiplyAssign=40
    DivideAssign=41
    ModulusAssign=42
    PlusAssign=43
    MinusAssign=44
    LeftShiftArithmeticAssign=45
    RightShiftArithmeticAssign=46
    RightShiftLogicalAssign=47
    BitAndAssign=48
    BitXorAssign=49
    BitOrAssign=50
    NullLiteral=51
    BooleanLiteral=52
    DecimalLiteral=53
    HexIntegerLiteral=54
    OctalIntegerLiteral=55
    Break=56
    Do=57
    Instanceof=58
    Typeof=59
    Case=60
    Else=61
    New=62
    Var=63
    Catch=64
    Finally=65
    Return=66
    Void=67
    Continue=68
    For=69
    Switch=70
    While=71
    Debugger=72
    Function=73
    This=74
    With=75
    Default=76
    If=77
    Throw=78
    Delete=79
    In=80
    Try=81
    Class=82
    Enum=83
    Extends=84
    Super=85
    Const=86
    Export=87
    Import=88
    Implements=89
    Let=90
    Private=91
    Public=92
    Interface=93
    Package=94
    Protected=95
    Static=96
    Yield=97
    Identifier=98
    StringLiteral=99
    WhiteSpaces=100
    MultiLineComment=101
    SingleLineComment=102
    UnexpectedCharacter=103

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    def here(self, type):
        """Returns `True` iff on the current index of the parser's
        token stream a token of the given `type` exists on the
        `HIDDEN` channel.

        Args:
            type (int): the type of the token on the `HIDDEN` channel
            to check.

        Returns:
            `True` iff on the current index of the parser's
            token stream a token of the given `type` exists on the
            `HIDDEN` channel.
        """
        # Get the token ahead of the current index.
        possibleIndexEosToken = self.getCurrentToken().tokenIndex - 1
        ahead = self._input.get(possibleIndexEosToken)

        # Check if the token resides on the HIDDEN channel and if it is of the
        # provided type.
        return (ahead.channel == Lexer.HIDDEN) and (ahead.type == type)

    def lineTerminatorAhead(self):
        """Returns `True` iff on the current index of the parser's
        token stream a token exists on the `HIDDEN` channel which
        either is a line terminator, or is a multi line comment that
        contains a line terminator.

        Returns:
            `True` iff on the current index of the parser's
            token stream a token exists on the `HIDDEN` channel which
            either is a line terminator, or is a multi line comment that
            contains a line terminator.
        """
        # Get the token ahead of the current index.
        possibleIndexEosToken = self.getCurrentToken().tokenIndex - 1
        ahead = self._input.get(possibleIndexEosToken)

        if ahead.channel != Lexer.HIDDEN:
            # We're only interested in tokens on the HIDDEN channel.
            return False

        if ahead.type == ECMAScriptParser.LineTerminator:
            # There is definitely a line terminator ahead.
            return True

        if ahead.type == ECMAScriptParser.WhiteSpaces:
            # Get the token ahead of the current whitespaces.
            possibleIndexEosToken = self.getCurrentToken().tokenIndex - 2
            ahead = self._input.get(possibleIndexEosToken)

        # Get the token's text and type.
        text = ahead.text
        type = ahead.type

        # Check if the token is, or contains a line terminator.
        return (type == ECMAScriptParser.MultiLineComment and \
            ('\r' in text or '\n' in text)) or \
            (type == ECMAScriptParser.LineTerminator)



    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ECMAScriptParser.EOF, 0)

        def sourceElements(self):
            return self.getTypedRuleContext(ECMAScriptParser.SourceElementsContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = ECMAScriptParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 110
                self.sourceElements()


            self.state = 113
            self.match(ECMAScriptParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceElementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SourceElementContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SourceElementContext,i)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_sourceElements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceElements" ):
                listener.enterSourceElements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceElements" ):
                listener.exitSourceElements(self)




    def sourceElements(self):

        localctx = ECMAScriptParser.SourceElementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sourceElements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 115
                    self.sourceElement()

                else:
                    raise NoViableAltException(self)
                self.state = 118 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(ECMAScriptParser.FunctionDeclarationContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_sourceElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceElement" ):
                listener.enterSourceElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceElement" ):
                listener.exitSourceElement(self)




    def sourceElement(self):

        localctx = ECMAScriptParser.SourceElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sourceElement)
        try:
            self.state = 123
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                if not self._input.LA(1) != ECMAScriptParser.Function:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LA(1) != ECMAScriptParser.Function")
                self.state = 121
                self.statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 122
                self.functionDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(ECMAScriptParser.BlockContext,0)


        def variableStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.VariableStatementContext,0)


        def emptyStatement_(self):
            return self.getTypedRuleContext(ECMAScriptParser.EmptyStatement_Context,0)


        def expressionStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.IfStatementContext,0)


        def iterationStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.IterationStatementContext,0)


        def continueStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.ContinueStatementContext,0)


        def breakStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.BreakStatementContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.ReturnStatementContext,0)


        def withStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.WithStatementContext,0)


        def labelledStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.LabelledStatementContext,0)


        def switchStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.SwitchStatementContext,0)


        def throwStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.ThrowStatementContext,0)


        def tryStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.TryStatementContext,0)


        def debuggerStatement(self):
            return self.getTypedRuleContext(ECMAScriptParser.DebuggerStatementContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = ECMAScriptParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statement)
        try:
            self.state = 141
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 126
                self.variableStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 127
                self.emptyStatement_()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 128
                if not self._input.LA(1) != ECMAScriptParser.OpenBrace:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LA(1) != ECMAScriptParser.OpenBrace")
                self.state = 129
                self.expressionStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 130
                self.ifStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 131
                self.iterationStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 132
                self.continueStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 133
                self.breakStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 134
                self.returnStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 135
                self.withStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 136
                self.labelledStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 137
                self.switchStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 138
                self.throwStatement()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 139
                self.tryStatement()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 140
                self.debuggerStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)

        def statementList(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)




    def block(self):

        localctx = ECMAScriptParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(ECMAScriptParser.OpenBrace)
            self.state = 145
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 144
                self.statementList()


            self.state = 147
            self.match(ECMAScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.StatementContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.StatementContext,i)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_statementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementList" ):
                listener.enterStatementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementList" ):
                listener.exitStatementList(self)




    def statementList(self):

        localctx = ECMAScriptParser.StatementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_statementList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 149
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 152 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Var(self):
            return self.getToken(ECMAScriptParser.Var, 0)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(ECMAScriptParser.VariableDeclarationListContext,0)


        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_variableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableStatement" ):
                listener.enterVariableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableStatement" ):
                listener.exitVariableStatement(self)




    def variableStatement(self):

        localctx = ECMAScriptParser.VariableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_variableStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(ECMAScriptParser.Var)
            self.state = 155
            self.variableDeclarationList()
            self.state = 156
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.VariableDeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_variableDeclarationList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclarationList" ):
                listener.enterVariableDeclarationList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclarationList" ):
                listener.exitVariableDeclarationList(self)




    def variableDeclarationList(self):

        localctx = ECMAScriptParser.VariableDeclarationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_variableDeclarationList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.variableDeclaration()
            self.state = 163
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 159
                    self.match(ECMAScriptParser.Comma)
                    self.state = 160
                    self.variableDeclaration() 
                self.state = 165
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def initialiser(self):
            return self.getTypedRuleContext(ECMAScriptParser.InitialiserContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)




    def variableDeclaration(self):

        localctx = ECMAScriptParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_variableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(ECMAScriptParser.Identifier)
            self.state = 168
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 167
                self.initialiser()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitialiserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Assign(self):
            return self.getToken(ECMAScriptParser.Assign, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_initialiser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialiser" ):
                listener.enterInitialiser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialiser" ):
                listener.exitInitialiser(self)




    def initialiser(self):

        localctx = ECMAScriptParser.InitialiserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_initialiser)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(ECMAScriptParser.Assign)
            self.state = 171
            self.singleExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmptyStatement_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SemiColon(self):
            return self.getToken(ECMAScriptParser.SemiColon, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_emptyStatement_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyStatement_" ):
                listener.enterEmptyStatement_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyStatement_" ):
                listener.exitEmptyStatement_(self)




    def emptyStatement_(self):

        localctx = ECMAScriptParser.EmptyStatement_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_emptyStatement_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(ECMAScriptParser.SemiColon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_expressionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatement" ):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatement" ):
                listener.exitExpressionStatement(self)




    def expressionStatement(self):

        localctx = ECMAScriptParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.expressionSequence()
            self.state = 176
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(ECMAScriptParser.If, 0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.StatementContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.StatementContext,i)


        def Else(self):
            return self.getToken(ECMAScriptParser.Else, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)




    def ifStatement(self):

        localctx = ECMAScriptParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(ECMAScriptParser.If)
            self.state = 179
            self.match(ECMAScriptParser.OpenParen)
            self.state = 180
            self.expressionSequence()
            self.state = 181
            self.match(ECMAScriptParser.CloseParen)
            self.state = 182
            self.statement()
            self.state = 185
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 183
                self.match(ECMAScriptParser.Else)
                self.state = 184
                self.statement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IterationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_iterationStatement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DoStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Do(self):
            return self.getToken(ECMAScriptParser.Do, 0)
        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)

        def While(self):
            return self.getToken(ECMAScriptParser.While, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoStatement" ):
                listener.enterDoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoStatement" ):
                listener.exitDoStatement(self)


    class ForVarStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(ECMAScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def Var(self):
            return self.getToken(ECMAScriptParser.Var, 0)
        def variableDeclarationList(self):
            return self.getTypedRuleContext(ECMAScriptParser.VariableDeclarationListContext,0)

        def SemiColon(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.SemiColon)
            else:
                return self.getToken(ECMAScriptParser.SemiColon, i)
        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)

        def expressionSequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.ExpressionSequenceContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForVarStatement" ):
                listener.enterForVarStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForVarStatement" ):
                listener.exitForVarStatement(self)


    class ForVarInStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(ECMAScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def Var(self):
            return self.getToken(ECMAScriptParser.Var, 0)
        def variableDeclaration(self):
            return self.getTypedRuleContext(ECMAScriptParser.VariableDeclarationContext,0)

        def In(self):
            return self.getToken(ECMAScriptParser.In, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForVarInStatement" ):
                listener.enterForVarInStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForVarInStatement" ):
                listener.exitForVarInStatement(self)


    class WhileStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def While(self):
            return self.getToken(ECMAScriptParser.While, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)


    class ForStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(ECMAScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def SemiColon(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.SemiColon)
            else:
                return self.getToken(ECMAScriptParser.SemiColon, i)
        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)

        def expressionSequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.ExpressionSequenceContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)


    class ForInStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(ECMAScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def In(self):
            return self.getToken(ECMAScriptParser.In, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInStatement" ):
                listener.enterForInStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInStatement" ):
                listener.exitForInStatement(self)



    def iterationStatement(self):

        localctx = ECMAScriptParser.IterationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_iterationStatement)
        self._la = 0 # Token type
        try:
            self.state = 248
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                localctx = ECMAScriptParser.DoStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 187
                self.match(ECMAScriptParser.Do)
                self.state = 188
                self.statement()
                self.state = 189
                self.match(ECMAScriptParser.While)
                self.state = 190
                self.match(ECMAScriptParser.OpenParen)
                self.state = 191
                self.expressionSequence()
                self.state = 192
                self.match(ECMAScriptParser.CloseParen)
                self.state = 193
                self.eos()
                pass

            elif la_ == 2:
                localctx = ECMAScriptParser.WhileStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 195
                self.match(ECMAScriptParser.While)
                self.state = 196
                self.match(ECMAScriptParser.OpenParen)
                self.state = 197
                self.expressionSequence()
                self.state = 198
                self.match(ECMAScriptParser.CloseParen)
                self.state = 199
                self.statement()
                pass

            elif la_ == 3:
                localctx = ECMAScriptParser.ForStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 201
                self.match(ECMAScriptParser.For)
                self.state = 202
                self.match(ECMAScriptParser.OpenParen)
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5257952564957118634) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 6442455233) != 0):
                    self.state = 203
                    self.expressionSequence()


                self.state = 206
                self.match(ECMAScriptParser.SemiColon)
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5257952564957118634) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 6442455233) != 0):
                    self.state = 207
                    self.expressionSequence()


                self.state = 210
                self.match(ECMAScriptParser.SemiColon)
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5257952564957118634) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 6442455233) != 0):
                    self.state = 211
                    self.expressionSequence()


                self.state = 214
                self.match(ECMAScriptParser.CloseParen)
                self.state = 215
                self.statement()
                pass

            elif la_ == 4:
                localctx = ECMAScriptParser.ForVarStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 216
                self.match(ECMAScriptParser.For)
                self.state = 217
                self.match(ECMAScriptParser.OpenParen)
                self.state = 218
                self.match(ECMAScriptParser.Var)
                self.state = 219
                self.variableDeclarationList()
                self.state = 220
                self.match(ECMAScriptParser.SemiColon)
                self.state = 222
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5257952564957118634) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 6442455233) != 0):
                    self.state = 221
                    self.expressionSequence()


                self.state = 224
                self.match(ECMAScriptParser.SemiColon)
                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5257952564957118634) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 6442455233) != 0):
                    self.state = 225
                    self.expressionSequence()


                self.state = 228
                self.match(ECMAScriptParser.CloseParen)
                self.state = 229
                self.statement()
                pass

            elif la_ == 5:
                localctx = ECMAScriptParser.ForInStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 231
                self.match(ECMAScriptParser.For)
                self.state = 232
                self.match(ECMAScriptParser.OpenParen)
                self.state = 233
                self.singleExpression(0)
                self.state = 234
                self.match(ECMAScriptParser.In)
                self.state = 235
                self.expressionSequence()
                self.state = 236
                self.match(ECMAScriptParser.CloseParen)
                self.state = 237
                self.statement()
                pass

            elif la_ == 6:
                localctx = ECMAScriptParser.ForVarInStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 239
                self.match(ECMAScriptParser.For)
                self.state = 240
                self.match(ECMAScriptParser.OpenParen)
                self.state = 241
                self.match(ECMAScriptParser.Var)
                self.state = 242
                self.variableDeclaration()
                self.state = 243
                self.match(ECMAScriptParser.In)
                self.state = 244
                self.expressionSequence()
                self.state = 245
                self.match(ECMAScriptParser.CloseParen)
                self.state = 246
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Continue(self):
            return self.getToken(ECMAScriptParser.Continue, 0)

        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_continueStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueStatement" ):
                listener.enterContinueStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueStatement" ):
                listener.exitContinueStatement(self)




    def continueStatement(self):

        localctx = ECMAScriptParser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_continueStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(ECMAScriptParser.Continue)
            self.state = 253
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 251
                if not not self.here(ECMAScriptParser.LineTerminator):
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.here(ECMAScriptParser.LineTerminator)")
                self.state = 252
                self.match(ECMAScriptParser.Identifier)


            self.state = 255
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(ECMAScriptParser.Break, 0)

        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_breakStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakStatement" ):
                listener.enterBreakStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakStatement" ):
                listener.exitBreakStatement(self)




    def breakStatement(self):

        localctx = ECMAScriptParser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_breakStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(ECMAScriptParser.Break)
            self.state = 260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 258
                if not not self.here(ECMAScriptParser.LineTerminator):
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.here(ECMAScriptParser.LineTerminator)")
                self.state = 259
                self.match(ECMAScriptParser.Identifier)


            self.state = 262
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Return(self):
            return self.getToken(ECMAScriptParser.Return, 0)

        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)




    def returnStatement(self):

        localctx = ECMAScriptParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(ECMAScriptParser.Return)
            self.state = 267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 265
                if not not self.here(ECMAScriptParser.LineTerminator):
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.here(ECMAScriptParser.LineTerminator)")
                self.state = 266
                self.expressionSequence()


            self.state = 269
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def With(self):
            return self.getToken(ECMAScriptParser.With, 0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_withStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithStatement" ):
                listener.enterWithStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithStatement" ):
                listener.exitWithStatement(self)




    def withStatement(self):

        localctx = ECMAScriptParser.WithStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_withStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(ECMAScriptParser.With)
            self.state = 272
            self.match(ECMAScriptParser.OpenParen)
            self.state = 273
            self.expressionSequence()
            self.state = 274
            self.match(ECMAScriptParser.CloseParen)
            self.state = 275
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Switch(self):
            return self.getToken(ECMAScriptParser.Switch, 0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def caseBlock(self):
            return self.getTypedRuleContext(ECMAScriptParser.CaseBlockContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_switchStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchStatement" ):
                listener.enterSwitchStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchStatement" ):
                listener.exitSwitchStatement(self)




    def switchStatement(self):

        localctx = ECMAScriptParser.SwitchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_switchStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.match(ECMAScriptParser.Switch)
            self.state = 278
            self.match(ECMAScriptParser.OpenParen)
            self.state = 279
            self.expressionSequence()
            self.state = 280
            self.match(ECMAScriptParser.CloseParen)
            self.state = 281
            self.caseBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)

        def caseClauses(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.CaseClausesContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.CaseClausesContext,i)


        def defaultClause(self):
            return self.getTypedRuleContext(ECMAScriptParser.DefaultClauseContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_caseBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseBlock" ):
                listener.enterCaseBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseBlock" ):
                listener.exitCaseBlock(self)




    def caseBlock(self):

        localctx = ECMAScriptParser.CaseBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_caseBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(ECMAScriptParser.OpenBrace)
            self.state = 285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 284
                self.caseClauses()


            self.state = 291
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==76:
                self.state = 287
                self.defaultClause()
                self.state = 289
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==60:
                    self.state = 288
                    self.caseClauses()




            self.state = 293
            self.match(ECMAScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.CaseClauseContext,i)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_caseClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClauses" ):
                listener.enterCaseClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClauses" ):
                listener.exitCaseClauses(self)




    def caseClauses(self):

        localctx = ECMAScriptParser.CaseClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_caseClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 295
                self.caseClause()
                self.state = 298 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==60):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Case(self):
            return self.getToken(ECMAScriptParser.Case, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def Colon(self):
            return self.getToken(ECMAScriptParser.Colon, 0)

        def statementList(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)




    def caseClause(self):

        localctx = ECMAScriptParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_caseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(ECMAScriptParser.Case)
            self.state = 301
            self.expressionSequence()
            self.state = 302
            self.match(ECMAScriptParser.Colon)
            self.state = 304
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 303
                self.statementList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Default(self):
            return self.getToken(ECMAScriptParser.Default, 0)

        def Colon(self):
            return self.getToken(ECMAScriptParser.Colon, 0)

        def statementList(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_defaultClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultClause" ):
                listener.enterDefaultClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultClause" ):
                listener.exitDefaultClause(self)




    def defaultClause(self):

        localctx = ECMAScriptParser.DefaultClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_defaultClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(ECMAScriptParser.Default)
            self.state = 307
            self.match(ECMAScriptParser.Colon)
            self.state = 309
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 308
                self.statementList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelledStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def Colon(self):
            return self.getToken(ECMAScriptParser.Colon, 0)

        def statement(self):
            return self.getTypedRuleContext(ECMAScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_labelledStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelledStatement" ):
                listener.enterLabelledStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelledStatement" ):
                listener.exitLabelledStatement(self)




    def labelledStatement(self):

        localctx = ECMAScriptParser.LabelledStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_labelledStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.match(ECMAScriptParser.Identifier)
            self.state = 312
            self.match(ECMAScriptParser.Colon)
            self.state = 313
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThrowStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Throw(self):
            return self.getToken(ECMAScriptParser.Throw, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)


        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_throwStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThrowStatement" ):
                listener.enterThrowStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThrowStatement" ):
                listener.exitThrowStatement(self)




    def throwStatement(self):

        localctx = ECMAScriptParser.ThrowStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_throwStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self.match(ECMAScriptParser.Throw)
            self.state = 316
            if not not self.here(ECMAScriptParser.LineTerminator):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "not self.here(ECMAScriptParser.LineTerminator)")
            self.state = 317
            self.expressionSequence()
            self.state = 318
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TryStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Try(self):
            return self.getToken(ECMAScriptParser.Try, 0)

        def block(self):
            return self.getTypedRuleContext(ECMAScriptParser.BlockContext,0)


        def catchProduction(self):
            return self.getTypedRuleContext(ECMAScriptParser.CatchProductionContext,0)


        def finallyProduction(self):
            return self.getTypedRuleContext(ECMAScriptParser.FinallyProductionContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_tryStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTryStatement" ):
                listener.enterTryStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTryStatement" ):
                listener.exitTryStatement(self)




    def tryStatement(self):

        localctx = ECMAScriptParser.TryStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_tryStatement)
        try:
            self.state = 333
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.match(ECMAScriptParser.Try)
                self.state = 321
                self.block()
                self.state = 322
                self.catchProduction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 324
                self.match(ECMAScriptParser.Try)
                self.state = 325
                self.block()
                self.state = 326
                self.finallyProduction()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 328
                self.match(ECMAScriptParser.Try)
                self.state = 329
                self.block()
                self.state = 330
                self.catchProduction()
                self.state = 331
                self.finallyProduction()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CatchProductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Catch(self):
            return self.getToken(ECMAScriptParser.Catch, 0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def block(self):
            return self.getTypedRuleContext(ECMAScriptParser.BlockContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_catchProduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatchProduction" ):
                listener.enterCatchProduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatchProduction" ):
                listener.exitCatchProduction(self)




    def catchProduction(self):

        localctx = ECMAScriptParser.CatchProductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_catchProduction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.match(ECMAScriptParser.Catch)
            self.state = 336
            self.match(ECMAScriptParser.OpenParen)
            self.state = 337
            self.match(ECMAScriptParser.Identifier)
            self.state = 338
            self.match(ECMAScriptParser.CloseParen)
            self.state = 339
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FinallyProductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Finally(self):
            return self.getToken(ECMAScriptParser.Finally, 0)

        def block(self):
            return self.getTypedRuleContext(ECMAScriptParser.BlockContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_finallyProduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFinallyProduction" ):
                listener.enterFinallyProduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFinallyProduction" ):
                listener.exitFinallyProduction(self)




    def finallyProduction(self):

        localctx = ECMAScriptParser.FinallyProductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_finallyProduction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(ECMAScriptParser.Finally)
            self.state = 342
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DebuggerStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Debugger(self):
            return self.getToken(ECMAScriptParser.Debugger, 0)

        def eos(self):
            return self.getTypedRuleContext(ECMAScriptParser.EosContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_debuggerStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDebuggerStatement" ):
                listener.enterDebuggerStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDebuggerStatement" ):
                listener.exitDebuggerStatement(self)




    def debuggerStatement(self):

        localctx = ECMAScriptParser.DebuggerStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_debuggerStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(ECMAScriptParser.Debugger)
            self.state = 345
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Function(self):
            return self.getToken(ECMAScriptParser.Function, 0)

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)

        def functionBody(self):
            return self.getTypedRuleContext(ECMAScriptParser.FunctionBodyContext,0)


        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(ECMAScriptParser.FormalParameterListContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)




    def functionDeclaration(self):

        localctx = ECMAScriptParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.match(ECMAScriptParser.Function)
            self.state = 348
            self.match(ECMAScriptParser.Identifier)
            self.state = 349
            self.match(ECMAScriptParser.OpenParen)
            self.state = 351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 350
                self.formalParameterList()


            self.state = 353
            self.match(ECMAScriptParser.CloseParen)
            self.state = 354
            self.match(ECMAScriptParser.OpenBrace)
            self.state = 355
            self.functionBody()
            self.state = 356
            self.match(ECMAScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Identifier)
            else:
                return self.getToken(ECMAScriptParser.Identifier, i)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_formalParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParameterList" ):
                listener.enterFormalParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParameterList" ):
                listener.exitFormalParameterList(self)




    def formalParameterList(self):

        localctx = ECMAScriptParser.FormalParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_formalParameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.match(ECMAScriptParser.Identifier)
            self.state = 363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 359
                self.match(ECMAScriptParser.Comma)
                self.state = 360
                self.match(ECMAScriptParser.Identifier)
                self.state = 365
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceElements(self):
            return self.getTypedRuleContext(ECMAScriptParser.SourceElementsContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_functionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionBody" ):
                listener.enterFunctionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionBody" ):
                listener.exitFunctionBody(self)




    def functionBody(self):

        localctx = ECMAScriptParser.FunctionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_functionBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 367
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 366
                self.sourceElements()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBracket(self):
            return self.getToken(ECMAScriptParser.OpenBracket, 0)

        def CloseBracket(self):
            return self.getToken(ECMAScriptParser.CloseBracket, 0)

        def elementList(self):
            return self.getTypedRuleContext(ECMAScriptParser.ElementListContext,0)


        def Comma(self):
            return self.getToken(ECMAScriptParser.Comma, 0)

        def elision(self):
            return self.getTypedRuleContext(ECMAScriptParser.ElisionContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_arrayLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLiteral" ):
                listener.enterArrayLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLiteral" ):
                listener.exitArrayLiteral(self)




    def arrayLiteral(self):

        localctx = ECMAScriptParser.ArrayLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_arrayLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 369
            self.match(ECMAScriptParser.OpenBracket)
            self.state = 371
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.state = 370
                self.elementList()


            self.state = 374
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.state = 373
                self.match(ECMAScriptParser.Comma)


            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 376
                self.elision()


            self.state = 379
            self.match(ECMAScriptParser.CloseBracket)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)


        def elision(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.ElisionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.ElisionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = ECMAScriptParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 381
                self.elision()


            self.state = 384
            self.singleExpression(0)
            self.state = 392
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 385
                    self.match(ECMAScriptParser.Comma)
                    self.state = 387
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==10:
                        self.state = 386
                        self.elision()


                    self.state = 389
                    self.singleExpression(0) 
                self.state = 394
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_elision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElision" ):
                listener.enterElision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElision" ):
                listener.exitElision(self)




    def elision(self):

        localctx = ECMAScriptParser.ElisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_elision)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 395
                self.match(ECMAScriptParser.Comma)
                self.state = 398 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==10):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)

        def propertyNameAndValueList(self):
            return self.getTypedRuleContext(ECMAScriptParser.PropertyNameAndValueListContext,0)


        def Comma(self):
            return self.getToken(ECMAScriptParser.Comma, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_objectLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteral" ):
                listener.enterObjectLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteral" ):
                listener.exitObjectLiteral(self)




    def objectLiteral(self):

        localctx = ECMAScriptParser.ObjectLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_objectLiteral)
        self._la = 0 # Token type
        try:
            self.state = 409
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 400
                self.match(ECMAScriptParser.OpenBrace)
                self.state = 401
                self.match(ECMAScriptParser.CloseBrace)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 402
                self.match(ECMAScriptParser.OpenBrace)
                self.state = 403
                self.propertyNameAndValueList()
                self.state = 405
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==10:
                    self.state = 404
                    self.match(ECMAScriptParser.Comma)


                self.state = 407
                self.match(ECMAScriptParser.CloseBrace)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyNameAndValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.PropertyAssignmentContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.PropertyAssignmentContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_propertyNameAndValueList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyNameAndValueList" ):
                listener.enterPropertyNameAndValueList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyNameAndValueList" ):
                listener.exitPropertyNameAndValueList(self)




    def propertyNameAndValueList(self):

        localctx = ECMAScriptParser.PropertyNameAndValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_propertyNameAndValueList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 411
            self.propertyAssignment()
            self.state = 416
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,37,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 412
                    self.match(ECMAScriptParser.Comma)
                    self.state = 413
                    self.propertyAssignment() 
                self.state = 418
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_propertyAssignment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PropertyExpressionAssignmentContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def propertyName(self):
            return self.getTypedRuleContext(ECMAScriptParser.PropertyNameContext,0)

        def Colon(self):
            return self.getToken(ECMAScriptParser.Colon, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyExpressionAssignment" ):
                listener.enterPropertyExpressionAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyExpressionAssignment" ):
                listener.exitPropertyExpressionAssignment(self)


    class PropertySetterContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def setter(self):
            return self.getTypedRuleContext(ECMAScriptParser.SetterContext,0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def propertySetParameterList(self):
            return self.getTypedRuleContext(ECMAScriptParser.PropertySetParameterListContext,0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)
        def functionBody(self):
            return self.getTypedRuleContext(ECMAScriptParser.FunctionBodyContext,0)

        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySetter" ):
                listener.enterPropertySetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySetter" ):
                listener.exitPropertySetter(self)


    class PropertyGetterContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def getter(self):
            return self.getTypedRuleContext(ECMAScriptParser.GetterContext,0)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)
        def functionBody(self):
            return self.getTypedRuleContext(ECMAScriptParser.FunctionBodyContext,0)

        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyGetter" ):
                listener.enterPropertyGetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyGetter" ):
                listener.exitPropertyGetter(self)



    def propertyAssignment(self):

        localctx = ECMAScriptParser.PropertyAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_propertyAssignment)
        try:
            self.state = 438
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                localctx = ECMAScriptParser.PropertyExpressionAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 419
                self.propertyName()
                self.state = 420
                self.match(ECMAScriptParser.Colon)
                self.state = 421
                self.singleExpression(0)
                pass

            elif la_ == 2:
                localctx = ECMAScriptParser.PropertyGetterContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 423
                self.getter()
                self.state = 424
                self.match(ECMAScriptParser.OpenParen)
                self.state = 425
                self.match(ECMAScriptParser.CloseParen)
                self.state = 426
                self.match(ECMAScriptParser.OpenBrace)
                self.state = 427
                self.functionBody()
                self.state = 428
                self.match(ECMAScriptParser.CloseBrace)
                pass

            elif la_ == 3:
                localctx = ECMAScriptParser.PropertySetterContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 430
                self.setter()
                self.state = 431
                self.match(ECMAScriptParser.OpenParen)
                self.state = 432
                self.propertySetParameterList()
                self.state = 433
                self.match(ECMAScriptParser.CloseParen)
                self.state = 434
                self.match(ECMAScriptParser.OpenBrace)
                self.state = 435
                self.functionBody()
                self.state = 436
                self.match(ECMAScriptParser.CloseBrace)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierName(self):
            return self.getTypedRuleContext(ECMAScriptParser.IdentifierNameContext,0)


        def StringLiteral(self):
            return self.getToken(ECMAScriptParser.StringLiteral, 0)

        def numericLiteral(self):
            return self.getTypedRuleContext(ECMAScriptParser.NumericLiteralContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_propertyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyName" ):
                listener.enterPropertyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyName" ):
                listener.exitPropertyName(self)




    def propertyName(self):

        localctx = ECMAScriptParser.PropertyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_propertyName)
        try:
            self.state = 443
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51, 52, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98]:
                self.enterOuterAlt(localctx, 1)
                self.state = 440
                self.identifierName()
                pass
            elif token in [99]:
                self.enterOuterAlt(localctx, 2)
                self.state = 441
                self.match(ECMAScriptParser.StringLiteral)
                pass
            elif token in [53, 54, 55]:
                self.enterOuterAlt(localctx, 3)
                self.state = 442
                self.numericLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertySetParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_propertySetParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySetParameterList" ):
                listener.enterPropertySetParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySetParameterList" ):
                listener.exitPropertySetParameterList(self)




    def propertySetParameterList(self):

        localctx = ECMAScriptParser.PropertySetParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_propertySetParameterList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 445
            self.match(ECMAScriptParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def argumentList(self):
            return self.getTypedRuleContext(ECMAScriptParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments" ):
                listener.enterArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments" ):
                listener.exitArguments(self)




    def arguments(self):

        localctx = ECMAScriptParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(ECMAScriptParser.OpenParen)
            self.state = 449
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5257952564957118634) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 6442455233) != 0):
                self.state = 448
                self.argumentList()


            self.state = 451
            self.match(ECMAScriptParser.CloseParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)




    def argumentList(self):

        localctx = ECMAScriptParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 453
            self.singleExpression(0)
            self.state = 458
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 454
                self.match(ECMAScriptParser.Comma)
                self.state = 455
                self.singleExpression(0)
                self.state = 460
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionSequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(ECMAScriptParser.Comma)
            else:
                return self.getToken(ECMAScriptParser.Comma, i)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_expressionSequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionSequence" ):
                listener.enterExpressionSequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionSequence" ):
                listener.exitExpressionSequence(self)




    def expressionSequence(self):

        localctx = ECMAScriptParser.ExpressionSequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_expressionSequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 461
            self.singleExpression(0)
            self.state = 466
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 462
                    self.match(ECMAScriptParser.Comma)
                    self.state = 463
                    self.singleExpression(0) 
                self.state = 468
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_singleExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TernaryExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def QuestionMark(self):
            return self.getToken(ECMAScriptParser.QuestionMark, 0)
        def Colon(self):
            return self.getToken(ECMAScriptParser.Colon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTernaryExpression" ):
                listener.enterTernaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTernaryExpression" ):
                listener.exitTernaryExpression(self)


    class LogicalAndExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def And(self):
            return self.getToken(ECMAScriptParser.And, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalAndExpression" ):
                listener.enterLogicalAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalAndExpression" ):
                listener.exitLogicalAndExpression(self)


    class PreIncrementExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PlusPlus(self):
            return self.getToken(ECMAScriptParser.PlusPlus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreIncrementExpression" ):
                listener.enterPreIncrementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreIncrementExpression" ):
                listener.exitPreIncrementExpression(self)


    class ObjectLiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectLiteral(self):
            return self.getTypedRuleContext(ECMAScriptParser.ObjectLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteralExpression" ):
                listener.enterObjectLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteralExpression" ):
                listener.exitObjectLiteralExpression(self)


    class InExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def In(self):
            return self.getToken(ECMAScriptParser.In, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInExpression" ):
                listener.enterInExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInExpression" ):
                listener.exitInExpression(self)


    class LogicalOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def Or(self):
            return self.getToken(ECMAScriptParser.Or, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOrExpression" ):
                listener.enterLogicalOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOrExpression" ):
                listener.exitLogicalOrExpression(self)


    class NotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Not(self):
            return self.getToken(ECMAScriptParser.Not, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotExpression" ):
                listener.enterNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotExpression" ):
                listener.exitNotExpression(self)


    class PreDecreaseExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MinusMinus(self):
            return self.getToken(ECMAScriptParser.MinusMinus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreDecreaseExpression" ):
                listener.enterPreDecreaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreDecreaseExpression" ):
                listener.exitPreDecreaseExpression(self)


    class ArgumentsExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def arguments(self):
            return self.getTypedRuleContext(ECMAScriptParser.ArgumentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentsExpression" ):
                listener.enterArgumentsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentsExpression" ):
                listener.exitArgumentsExpression(self)


    class ThisExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def This(self):
            return self.getToken(ECMAScriptParser.This, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThisExpression" ):
                listener.enterThisExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThisExpression" ):
                listener.exitThisExpression(self)


    class FunctionExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Function(self):
            return self.getToken(ECMAScriptParser.Function, 0)
        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)
        def OpenBrace(self):
            return self.getToken(ECMAScriptParser.OpenBrace, 0)
        def functionBody(self):
            return self.getTypedRuleContext(ECMAScriptParser.FunctionBodyContext,0)

        def CloseBrace(self):
            return self.getToken(ECMAScriptParser.CloseBrace, 0)
        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)
        def formalParameterList(self):
            return self.getTypedRuleContext(ECMAScriptParser.FormalParameterListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExpression" ):
                listener.enterFunctionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExpression" ):
                listener.exitFunctionExpression(self)


    class UnaryMinusExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Minus(self):
            return self.getToken(ECMAScriptParser.Minus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpression" ):
                listener.enterUnaryMinusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpression" ):
                listener.exitUnaryMinusExpression(self)


    class AssignmentExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def Assign(self):
            return self.getToken(ECMAScriptParser.Assign, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentExpression" ):
                listener.enterAssignmentExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentExpression" ):
                listener.exitAssignmentExpression(self)


    class PostDecreaseExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def MinusMinus(self):
            return self.getToken(ECMAScriptParser.MinusMinus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostDecreaseExpression" ):
                listener.enterPostDecreaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostDecreaseExpression" ):
                listener.exitPostDecreaseExpression(self)


    class TypeofExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Typeof(self):
            return self.getToken(ECMAScriptParser.Typeof, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeofExpression" ):
                listener.enterTypeofExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeofExpression" ):
                listener.exitTypeofExpression(self)


    class InstanceofExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def Instanceof(self):
            return self.getToken(ECMAScriptParser.Instanceof, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstanceofExpression" ):
                listener.enterInstanceofExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstanceofExpression" ):
                listener.exitInstanceofExpression(self)


    class UnaryPlusExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Plus(self):
            return self.getToken(ECMAScriptParser.Plus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlusExpression" ):
                listener.enterUnaryPlusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlusExpression" ):
                listener.exitUnaryPlusExpression(self)


    class DeleteExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Delete(self):
            return self.getToken(ECMAScriptParser.Delete, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteExpression" ):
                listener.enterDeleteExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteExpression" ):
                listener.exitDeleteExpression(self)


    class EqualityExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def Equals(self):
            return self.getToken(ECMAScriptParser.Equals, 0)
        def NotEquals(self):
            return self.getToken(ECMAScriptParser.NotEquals, 0)
        def IdentityEquals(self):
            return self.getToken(ECMAScriptParser.IdentityEquals, 0)
        def IdentityNotEquals(self):
            return self.getToken(ECMAScriptParser.IdentityNotEquals, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqualityExpression" ):
                listener.enterEqualityExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqualityExpression" ):
                listener.exitEqualityExpression(self)


    class BitXOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def BitXOr(self):
            return self.getToken(ECMAScriptParser.BitXOr, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitXOrExpression" ):
                listener.enterBitXOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitXOrExpression" ):
                listener.exitBitXOrExpression(self)


    class MultiplicativeExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def Multiply(self):
            return self.getToken(ECMAScriptParser.Multiply, 0)
        def Divide(self):
            return self.getToken(ECMAScriptParser.Divide, 0)
        def Modulus(self):
            return self.getToken(ECMAScriptParser.Modulus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)


    class BitShiftExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def LeftShiftArithmetic(self):
            return self.getToken(ECMAScriptParser.LeftShiftArithmetic, 0)
        def RightShiftArithmetic(self):
            return self.getToken(ECMAScriptParser.RightShiftArithmetic, 0)
        def RightShiftLogical(self):
            return self.getToken(ECMAScriptParser.RightShiftLogical, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitShiftExpression" ):
                listener.enterBitShiftExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitShiftExpression" ):
                listener.exitBitShiftExpression(self)


    class ParenthesizedExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OpenParen(self):
            return self.getToken(ECMAScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(ECMAScriptParser.CloseParen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)


    class AdditiveExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def Plus(self):
            return self.getToken(ECMAScriptParser.Plus, 0)
        def Minus(self):
            return self.getToken(ECMAScriptParser.Minus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)


    class RelationalExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def LessThan(self):
            return self.getToken(ECMAScriptParser.LessThan, 0)
        def MoreThan(self):
            return self.getToken(ECMAScriptParser.MoreThan, 0)
        def LessThanEquals(self):
            return self.getToken(ECMAScriptParser.LessThanEquals, 0)
        def GreaterThanEquals(self):
            return self.getToken(ECMAScriptParser.GreaterThanEquals, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalExpression" ):
                listener.enterRelationalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalExpression" ):
                listener.exitRelationalExpression(self)


    class PostIncrementExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def PlusPlus(self):
            return self.getToken(ECMAScriptParser.PlusPlus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostIncrementExpression" ):
                listener.enterPostIncrementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostIncrementExpression" ):
                listener.exitPostIncrementExpression(self)


    class BitNotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BitNot(self):
            return self.getToken(ECMAScriptParser.BitNot, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitNotExpression" ):
                listener.enterBitNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitNotExpression" ):
                listener.exitBitNotExpression(self)


    class NewExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(ECMAScriptParser.New, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def arguments(self):
            return self.getTypedRuleContext(ECMAScriptParser.ArgumentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNewExpression" ):
                listener.enterNewExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNewExpression" ):
                listener.exitNewExpression(self)


    class LiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(ECMAScriptParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralExpression" ):
                listener.enterLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralExpression" ):
                listener.exitLiteralExpression(self)


    class ArrayLiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def arrayLiteral(self):
            return self.getTypedRuleContext(ECMAScriptParser.ArrayLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLiteralExpression" ):
                listener.enterArrayLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLiteralExpression" ):
                listener.exitArrayLiteralExpression(self)


    class MemberDotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def Dot(self):
            return self.getToken(ECMAScriptParser.Dot, 0)
        def identifierName(self):
            return self.getTypedRuleContext(ECMAScriptParser.IdentifierNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberDotExpression" ):
                listener.enterMemberDotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberDotExpression" ):
                listener.exitMemberDotExpression(self)


    class MemberIndexExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)

        def OpenBracket(self):
            return self.getToken(ECMAScriptParser.OpenBracket, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(ECMAScriptParser.ExpressionSequenceContext,0)

        def CloseBracket(self):
            return self.getToken(ECMAScriptParser.CloseBracket, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberIndexExpression" ):
                listener.enterMemberIndexExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberIndexExpression" ):
                listener.exitMemberIndexExpression(self)


    class IdentifierExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpression" ):
                listener.enterIdentifierExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpression" ):
                listener.exitIdentifierExpression(self)


    class BitAndExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def BitAnd(self):
            return self.getToken(ECMAScriptParser.BitAnd, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitAndExpression" ):
                listener.enterBitAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitAndExpression" ):
                listener.exitBitAndExpression(self)


    class BitOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def BitOr(self):
            return self.getToken(ECMAScriptParser.BitOr, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitOrExpression" ):
                listener.enterBitOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitOrExpression" ):
                listener.exitBitOrExpression(self)


    class AssignmentOperatorExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECMAScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,i)

        def assignmentOperator(self):
            return self.getTypedRuleContext(ECMAScriptParser.AssignmentOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperatorExpression" ):
                listener.enterAssignmentOperatorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperatorExpression" ):
                listener.exitAssignmentOperatorExpression(self)


    class VoidExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ECMAScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Void(self):
            return self.getToken(ECMAScriptParser.Void, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(ECMAScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoidExpression" ):
                listener.enterVoidExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoidExpression" ):
                listener.exitVoidExpression(self)



    def singleExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ECMAScriptParser.SingleExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 86
        self.enterRecursionRule(localctx, 86, self.RULE_singleExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [73]:
                localctx = ECMAScriptParser.FunctionExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 470
                self.match(ECMAScriptParser.Function)
                self.state = 472
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==98:
                    self.state = 471
                    self.match(ECMAScriptParser.Identifier)


                self.state = 474
                self.match(ECMAScriptParser.OpenParen)
                self.state = 476
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==98:
                    self.state = 475
                    self.formalParameterList()


                self.state = 478
                self.match(ECMAScriptParser.CloseParen)
                self.state = 479
                self.match(ECMAScriptParser.OpenBrace)
                self.state = 480
                self.functionBody()
                self.state = 481
                self.match(ECMAScriptParser.CloseBrace)
                pass
            elif token in [62]:
                localctx = ECMAScriptParser.NewExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 483
                self.match(ECMAScriptParser.New)
                self.state = 484
                self.singleExpression(0)
                self.state = 486
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 485
                    self.arguments()


                pass
            elif token in [79]:
                localctx = ECMAScriptParser.DeleteExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 488
                self.match(ECMAScriptParser.Delete)
                self.state = 489
                self.singleExpression(30)
                pass
            elif token in [67]:
                localctx = ECMAScriptParser.VoidExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 490
                self.match(ECMAScriptParser.Void)
                self.state = 491
                self.singleExpression(29)
                pass
            elif token in [59]:
                localctx = ECMAScriptParser.TypeofExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 492
                self.match(ECMAScriptParser.Typeof)
                self.state = 493
                self.singleExpression(28)
                pass
            elif token in [15]:
                localctx = ECMAScriptParser.PreIncrementExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 494
                self.match(ECMAScriptParser.PlusPlus)
                self.state = 495
                self.singleExpression(27)
                pass
            elif token in [16]:
                localctx = ECMAScriptParser.PreDecreaseExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 496
                self.match(ECMAScriptParser.MinusMinus)
                self.state = 497
                self.singleExpression(26)
                pass
            elif token in [17]:
                localctx = ECMAScriptParser.UnaryPlusExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 498
                self.match(ECMAScriptParser.Plus)
                self.state = 499
                self.singleExpression(25)
                pass
            elif token in [18]:
                localctx = ECMAScriptParser.UnaryMinusExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 500
                self.match(ECMAScriptParser.Minus)
                self.state = 501
                self.singleExpression(24)
                pass
            elif token in [19]:
                localctx = ECMAScriptParser.BitNotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 502
                self.match(ECMAScriptParser.BitNot)
                self.state = 503
                self.singleExpression(23)
                pass
            elif token in [20]:
                localctx = ECMAScriptParser.NotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 504
                self.match(ECMAScriptParser.Not)
                self.state = 505
                self.singleExpression(22)
                pass
            elif token in [74]:
                localctx = ECMAScriptParser.ThisExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 506
                self.match(ECMAScriptParser.This)
                pass
            elif token in [98]:
                localctx = ECMAScriptParser.IdentifierExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 507
                self.match(ECMAScriptParser.Identifier)
                pass
            elif token in [1, 51, 52, 53, 54, 55, 99]:
                localctx = ECMAScriptParser.LiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 508
                self.literal()
                pass
            elif token in [3]:
                localctx = ECMAScriptParser.ArrayLiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 509
                self.arrayLiteral()
                pass
            elif token in [7]:
                localctx = ECMAScriptParser.ObjectLiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 510
                self.objectLiteral()
                pass
            elif token in [5]:
                localctx = ECMAScriptParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 511
                self.match(ECMAScriptParser.OpenParen)
                self.state = 512
                self.expressionSequence()
                self.state = 513
                self.match(ECMAScriptParser.CloseParen)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 584
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,48,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 582
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                    if la_ == 1:
                        localctx = ECMAScriptParser.MultiplicativeExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 517
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 518
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 14680064) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 519
                        self.singleExpression(22)
                        pass

                    elif la_ == 2:
                        localctx = ECMAScriptParser.AdditiveExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 520
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 521
                        _la = self._input.LA(1)
                        if not(_la==17 or _la==18):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 522
                        self.singleExpression(21)
                        pass

                    elif la_ == 3:
                        localctx = ECMAScriptParser.BitShiftExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 523
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 524
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 117440512) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 525
                        self.singleExpression(20)
                        pass

                    elif la_ == 4:
                        localctx = ECMAScriptParser.RelationalExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 526
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 527
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2013265920) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 528
                        self.singleExpression(19)
                        pass

                    elif la_ == 5:
                        localctx = ECMAScriptParser.InstanceofExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 529
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 530
                        self.match(ECMAScriptParser.Instanceof)
                        self.state = 531
                        self.singleExpression(18)
                        pass

                    elif la_ == 6:
                        localctx = ECMAScriptParser.InExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 532
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 533
                        self.match(ECMAScriptParser.In)
                        self.state = 534
                        self.singleExpression(17)
                        pass

                    elif la_ == 7:
                        localctx = ECMAScriptParser.EqualityExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 535
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 536
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 32212254720) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 537
                        self.singleExpression(16)
                        pass

                    elif la_ == 8:
                        localctx = ECMAScriptParser.BitAndExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 538
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 539
                        self.match(ECMAScriptParser.BitAnd)
                        self.state = 540
                        self.singleExpression(15)
                        pass

                    elif la_ == 9:
                        localctx = ECMAScriptParser.BitXOrExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 541
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 542
                        self.match(ECMAScriptParser.BitXOr)
                        self.state = 543
                        self.singleExpression(14)
                        pass

                    elif la_ == 10:
                        localctx = ECMAScriptParser.BitOrExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 544
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 545
                        self.match(ECMAScriptParser.BitOr)
                        self.state = 546
                        self.singleExpression(13)
                        pass

                    elif la_ == 11:
                        localctx = ECMAScriptParser.LogicalAndExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 547
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 548
                        self.match(ECMAScriptParser.And)
                        self.state = 549
                        self.singleExpression(12)
                        pass

                    elif la_ == 12:
                        localctx = ECMAScriptParser.LogicalOrExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 550
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 551
                        self.match(ECMAScriptParser.Or)
                        self.state = 552
                        self.singleExpression(11)
                        pass

                    elif la_ == 13:
                        localctx = ECMAScriptParser.TernaryExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 553
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 554
                        self.match(ECMAScriptParser.QuestionMark)
                        self.state = 555
                        self.singleExpression(0)
                        self.state = 556
                        self.match(ECMAScriptParser.Colon)
                        self.state = 557
                        self.singleExpression(10)
                        pass

                    elif la_ == 14:
                        localctx = ECMAScriptParser.AssignmentExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 559
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 560
                        self.match(ECMAScriptParser.Assign)
                        self.state = 561
                        self.singleExpression(9)
                        pass

                    elif la_ == 15:
                        localctx = ECMAScriptParser.AssignmentOperatorExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 562
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 563
                        self.assignmentOperator()
                        self.state = 564
                        self.singleExpression(8)
                        pass

                    elif la_ == 16:
                        localctx = ECMAScriptParser.MemberIndexExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 566
                        if not self.precpred(self._ctx, 36):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 36)")
                        self.state = 567
                        self.match(ECMAScriptParser.OpenBracket)
                        self.state = 568
                        self.expressionSequence()
                        self.state = 569
                        self.match(ECMAScriptParser.CloseBracket)
                        pass

                    elif la_ == 17:
                        localctx = ECMAScriptParser.MemberDotExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 571
                        if not self.precpred(self._ctx, 35):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 35)")
                        self.state = 572
                        self.match(ECMAScriptParser.Dot)
                        self.state = 573
                        self.identifierName()
                        pass

                    elif la_ == 18:
                        localctx = ECMAScriptParser.ArgumentsExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 574
                        if not self.precpred(self._ctx, 34):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 34)")
                        self.state = 575
                        self.arguments()
                        pass

                    elif la_ == 19:
                        localctx = ECMAScriptParser.PostIncrementExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 576
                        if not self.precpred(self._ctx, 32):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 32)")
                        self.state = 577
                        if not not self.here(ECMAScriptParser.LineTerminator):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "not self.here(ECMAScriptParser.LineTerminator)")
                        self.state = 578
                        self.match(ECMAScriptParser.PlusPlus)
                        pass

                    elif la_ == 20:
                        localctx = ECMAScriptParser.PostDecreaseExpressionContext(self, ECMAScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 579
                        if not self.precpred(self._ctx, 31):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 31)")
                        self.state = 580
                        if not not self.here(ECMAScriptParser.LineTerminator):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "not self.here(ECMAScriptParser.LineTerminator)")
                        self.state = 581
                        self.match(ECMAScriptParser.MinusMinus)
                        pass

             
                self.state = 586
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MultiplyAssign(self):
            return self.getToken(ECMAScriptParser.MultiplyAssign, 0)

        def DivideAssign(self):
            return self.getToken(ECMAScriptParser.DivideAssign, 0)

        def ModulusAssign(self):
            return self.getToken(ECMAScriptParser.ModulusAssign, 0)

        def PlusAssign(self):
            return self.getToken(ECMAScriptParser.PlusAssign, 0)

        def MinusAssign(self):
            return self.getToken(ECMAScriptParser.MinusAssign, 0)

        def LeftShiftArithmeticAssign(self):
            return self.getToken(ECMAScriptParser.LeftShiftArithmeticAssign, 0)

        def RightShiftArithmeticAssign(self):
            return self.getToken(ECMAScriptParser.RightShiftArithmeticAssign, 0)

        def RightShiftLogicalAssign(self):
            return self.getToken(ECMAScriptParser.RightShiftLogicalAssign, 0)

        def BitAndAssign(self):
            return self.getToken(ECMAScriptParser.BitAndAssign, 0)

        def BitXorAssign(self):
            return self.getToken(ECMAScriptParser.BitXorAssign, 0)

        def BitOrAssign(self):
            return self.getToken(ECMAScriptParser.BitOrAssign, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_assignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperator" ):
                listener.enterAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperator" ):
                listener.exitAssignmentOperator(self)




    def assignmentOperator(self):

        localctx = ECMAScriptParser.AssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_assignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 587
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2250700302057472) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NullLiteral(self):
            return self.getToken(ECMAScriptParser.NullLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(ECMAScriptParser.BooleanLiteral, 0)

        def StringLiteral(self):
            return self.getToken(ECMAScriptParser.StringLiteral, 0)

        def RegularExpressionLiteral(self):
            return self.getToken(ECMAScriptParser.RegularExpressionLiteral, 0)

        def numericLiteral(self):
            return self.getTypedRuleContext(ECMAScriptParser.NumericLiteralContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = ECMAScriptParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.state = 591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 51, 52, 99]:
                self.enterOuterAlt(localctx, 1)
                self.state = 589
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6755399441055746) != 0) or _la==99):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [53, 54, 55]:
                self.enterOuterAlt(localctx, 2)
                self.state = 590
                self.numericLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DecimalLiteral(self):
            return self.getToken(ECMAScriptParser.DecimalLiteral, 0)

        def HexIntegerLiteral(self):
            return self.getToken(ECMAScriptParser.HexIntegerLiteral, 0)

        def OctalIntegerLiteral(self):
            return self.getToken(ECMAScriptParser.OctalIntegerLiteral, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)




    def numericLiteral(self):

        localctx = ECMAScriptParser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_numericLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 63050394783186944) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def reservedWord(self):
            return self.getTypedRuleContext(ECMAScriptParser.ReservedWordContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_identifierName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierName" ):
                listener.enterIdentifierName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierName" ):
                listener.exitIdentifierName(self)




    def identifierName(self):

        localctx = ECMAScriptParser.IdentifierNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_identifierName)
        try:
            self.state = 597
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98]:
                self.enterOuterAlt(localctx, 1)
                self.state = 595
                self.match(ECMAScriptParser.Identifier)
                pass
            elif token in [51, 52, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97]:
                self.enterOuterAlt(localctx, 2)
                self.state = 596
                self.reservedWord()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReservedWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyword(self):
            return self.getTypedRuleContext(ECMAScriptParser.KeywordContext,0)


        def futureReservedWord(self):
            return self.getTypedRuleContext(ECMAScriptParser.FutureReservedWordContext,0)


        def NullLiteral(self):
            return self.getToken(ECMAScriptParser.NullLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(ECMAScriptParser.BooleanLiteral, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_reservedWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReservedWord" ):
                listener.enterReservedWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReservedWord" ):
                listener.exitReservedWord(self)




    def reservedWord(self):

        localctx = ECMAScriptParser.ReservedWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_reservedWord)
        self._la = 0 # Token type
        try:
            self.state = 602
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81]:
                self.enterOuterAlt(localctx, 1)
                self.state = 599
                self.keyword()
                pass
            elif token in [82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97]:
                self.enterOuterAlt(localctx, 2)
                self.state = 600
                self.futureReservedWord()
                pass
            elif token in [51, 52]:
                self.enterOuterAlt(localctx, 3)
                self.state = 601
                _la = self._input.LA(1)
                if not(_la==51 or _la==52):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(ECMAScriptParser.Break, 0)

        def Do(self):
            return self.getToken(ECMAScriptParser.Do, 0)

        def Instanceof(self):
            return self.getToken(ECMAScriptParser.Instanceof, 0)

        def Typeof(self):
            return self.getToken(ECMAScriptParser.Typeof, 0)

        def Case(self):
            return self.getToken(ECMAScriptParser.Case, 0)

        def Else(self):
            return self.getToken(ECMAScriptParser.Else, 0)

        def New(self):
            return self.getToken(ECMAScriptParser.New, 0)

        def Var(self):
            return self.getToken(ECMAScriptParser.Var, 0)

        def Catch(self):
            return self.getToken(ECMAScriptParser.Catch, 0)

        def Finally(self):
            return self.getToken(ECMAScriptParser.Finally, 0)

        def Return(self):
            return self.getToken(ECMAScriptParser.Return, 0)

        def Void(self):
            return self.getToken(ECMAScriptParser.Void, 0)

        def Continue(self):
            return self.getToken(ECMAScriptParser.Continue, 0)

        def For(self):
            return self.getToken(ECMAScriptParser.For, 0)

        def Switch(self):
            return self.getToken(ECMAScriptParser.Switch, 0)

        def While(self):
            return self.getToken(ECMAScriptParser.While, 0)

        def Debugger(self):
            return self.getToken(ECMAScriptParser.Debugger, 0)

        def Function(self):
            return self.getToken(ECMAScriptParser.Function, 0)

        def This(self):
            return self.getToken(ECMAScriptParser.This, 0)

        def With(self):
            return self.getToken(ECMAScriptParser.With, 0)

        def Default(self):
            return self.getToken(ECMAScriptParser.Default, 0)

        def If(self):
            return self.getToken(ECMAScriptParser.If, 0)

        def Throw(self):
            return self.getToken(ECMAScriptParser.Throw, 0)

        def Delete(self):
            return self.getToken(ECMAScriptParser.Delete, 0)

        def In(self):
            return self.getToken(ECMAScriptParser.In, 0)

        def Try(self):
            return self.getToken(ECMAScriptParser.Try, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)




    def keyword(self):

        localctx = ECMAScriptParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_keyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 604
            _la = self._input.LA(1)
            if not(((((_la - 56)) & ~0x3f) == 0 and ((1 << (_la - 56)) & 67108863) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FutureReservedWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Class(self):
            return self.getToken(ECMAScriptParser.Class, 0)

        def Enum(self):
            return self.getToken(ECMAScriptParser.Enum, 0)

        def Extends(self):
            return self.getToken(ECMAScriptParser.Extends, 0)

        def Super(self):
            return self.getToken(ECMAScriptParser.Super, 0)

        def Const(self):
            return self.getToken(ECMAScriptParser.Const, 0)

        def Export(self):
            return self.getToken(ECMAScriptParser.Export, 0)

        def Import(self):
            return self.getToken(ECMAScriptParser.Import, 0)

        def Implements(self):
            return self.getToken(ECMAScriptParser.Implements, 0)

        def Let(self):
            return self.getToken(ECMAScriptParser.Let, 0)

        def Private(self):
            return self.getToken(ECMAScriptParser.Private, 0)

        def Public(self):
            return self.getToken(ECMAScriptParser.Public, 0)

        def Interface(self):
            return self.getToken(ECMAScriptParser.Interface, 0)

        def Package(self):
            return self.getToken(ECMAScriptParser.Package, 0)

        def Protected(self):
            return self.getToken(ECMAScriptParser.Protected, 0)

        def Static(self):
            return self.getToken(ECMAScriptParser.Static, 0)

        def Yield(self):
            return self.getToken(ECMAScriptParser.Yield, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_futureReservedWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFutureReservedWord" ):
                listener.enterFutureReservedWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFutureReservedWord" ):
                listener.exitFutureReservedWord(self)




    def futureReservedWord(self):

        localctx = ECMAScriptParser.FutureReservedWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_futureReservedWord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            _la = self._input.LA(1)
            if not(((((_la - 82)) & ~0x3f) == 0 and ((1 << (_la - 82)) & 65535) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def propertyName(self):
            return self.getTypedRuleContext(ECMAScriptParser.PropertyNameContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_getter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetter" ):
                listener.enterGetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetter" ):
                listener.exitGetter(self)




    def getter(self):

        localctx = ECMAScriptParser.GetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_getter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 608
            if not self._input.LT(1).text == "get":
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self._input.LT(1).text == \"get\"")
            self.state = 609
            self.match(ECMAScriptParser.Identifier)
            self.state = 610
            self.propertyName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(ECMAScriptParser.Identifier, 0)

        def propertyName(self):
            return self.getTypedRuleContext(ECMAScriptParser.PropertyNameContext,0)


        def getRuleIndex(self):
            return ECMAScriptParser.RULE_setter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetter" ):
                listener.enterSetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetter" ):
                listener.exitSetter(self)




    def setter(self):

        localctx = ECMAScriptParser.SetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_setter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            if not self._input.LT(1).text == "set":
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self._input.LT(1).text == \"set\"")
            self.state = 613
            self.match(ECMAScriptParser.Identifier)
            self.state = 614
            self.propertyName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EosContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SemiColon(self):
            return self.getToken(ECMAScriptParser.SemiColon, 0)

        def EOF(self):
            return self.getToken(ECMAScriptParser.EOF, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_eos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEos" ):
                listener.enterEos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEos" ):
                listener.exitEos(self)




    def eos(self):

        localctx = ECMAScriptParser.EosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_eos)
        try:
            self.state = 620
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 616
                self.match(ECMAScriptParser.SemiColon)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 617
                self.match(ECMAScriptParser.EOF)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 618
                if not self.lineTerminatorAhead():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.lineTerminatorAhead()")
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 619
                if not self._input.LT(1).type == ECMAScriptParser.CloseBrace:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LT(1).type == ECMAScriptParser.CloseBrace")
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ECMAScriptParser.EOF, 0)

        def getRuleIndex(self):
            return ECMAScriptParser.RULE_eof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEof" ):
                listener.enterEof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEof" ):
                listener.exitEof(self)




    def eof(self):

        localctx = ECMAScriptParser.EofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_eof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.match(ECMAScriptParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[2] = self.sourceElement_sempred
        self._predicates[3] = self.statement_sempred
        self._predicates[14] = self.continueStatement_sempred
        self._predicates[15] = self.breakStatement_sempred
        self._predicates[16] = self.returnStatement_sempred
        self._predicates[24] = self.throwStatement_sempred
        self._predicates[43] = self.singleExpression_sempred
        self._predicates[51] = self.getter_sempred
        self._predicates[52] = self.setter_sempred
        self._predicates[53] = self.eos_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def sourceElement_sempred(self, localctx:SourceElementContext, predIndex:int):
            if predIndex == 0:
                return self._input.LA(1) != ECMAScriptParser.Function
         

    def statement_sempred(self, localctx:StatementContext, predIndex:int):
            if predIndex == 1:
                return self._input.LA(1) != ECMAScriptParser.OpenBrace
         

    def continueStatement_sempred(self, localctx:ContinueStatementContext, predIndex:int):
            if predIndex == 2:
                return not self.here(ECMAScriptParser.LineTerminator)
         

    def breakStatement_sempred(self, localctx:BreakStatementContext, predIndex:int):
            if predIndex == 3:
                return not self.here(ECMAScriptParser.LineTerminator)
         

    def returnStatement_sempred(self, localctx:ReturnStatementContext, predIndex:int):
            if predIndex == 4:
                return not self.here(ECMAScriptParser.LineTerminator)
         

    def throwStatement_sempred(self, localctx:ThrowStatementContext, predIndex:int):
            if predIndex == 5:
                return not self.here(ECMAScriptParser.LineTerminator)
         

    def singleExpression_sempred(self, localctx:SingleExpressionContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 36)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 35)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 34)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 32)
         

            if predIndex == 25:
                return not self.here(ECMAScriptParser.LineTerminator)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 31)
         

            if predIndex == 27:
                return not self.here(ECMAScriptParser.LineTerminator)
         

    def getter_sempred(self, localctx:GetterContext, predIndex:int):
            if predIndex == 28:
                return self._input.LT(1).text == "get"
         

    def setter_sempred(self, localctx:SetterContext, predIndex:int):
            if predIndex == 29:
                return self._input.LT(1).text == "set"
         

    def eos_sempred(self, localctx:EosContext, predIndex:int):
            if predIndex == 30:
                return self.lineTerminatorAhead()
         

            if predIndex == 31:
                return self._input.LT(1).type == ECMAScriptParser.CloseBrace
         




